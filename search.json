[{"title":"java三大框架各自的作用","url":"/tech-notes/the-use-frame-1567928488.html","content":"一、Spring\n\nSpring是一个解决了许多在J2EE开发中常见的问题的强大框架。 Spring提供了管理业务对象的一致方法并且鼓励了注入对接口编程而不是对类编程的良好习惯。Spring的架构基础是基于使用JavaBean属性的Inversion of Control容器。然而，这仅仅是完整图景中的一部分：Spring在使用IoC容器作为构建完关注所有架构层的完整解决方案方面是独一无二的。 Spring提供了唯一的数据访问抽象，包括简单和有效率的JDBC框架，极大的改进了效率并且减少了可能的错误。Spring的数据访问架构还集成了Hibernate和其他O/R mapping解决方案。Spring还提供了唯一的事务管理抽象，它能够在各种底层事务管理技术，例如JTA或者JDBC事务提供一个一致的编程模型。Spring提供了一个用标准Java语言编写的AOP框架，它给POJOs提供了声明式的事务管理和其他企业事务--如果你需要--还能实现你自己的aspects。这个框架足够强大，使得应用程序能够抛开EJB的复杂性，同时享受着和传统EJB相关的关键服务。Spring还提供了可以和IoC容器集成的强大而灵活的MVC Web框架。\n\n二、STRUCTS\n\nStruts是一个基于Sun J2EE平台的MVC框架，主要是采用Servlet和JSP技术来实现的。由于Struts能充分满足应用开发的需求，简单易用，敏捷迅速，在过去的一年中颇受关注。Struts把Servlet、JSP、自定义标签和信息资源(message resources)整合到一个统一的框架中，开发人员利用其进行开发时不用再自己编码实现全套MVC模式，极大的节省了时间，所以说Struts是一个非常不错的应用框架。\n\n三、Hibernate\n\nHibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序实用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。映射很简单呀,就是页面的映射呀,多做点练习就会了,\n\nJAVA三大框架用来做WEN应用。 struts主要负责表示层的显示 spring利用它的IOC和AOP来处理控制业务（负责对数据库的操作） hibernate主要是数据的持久化到数据库 在用jsp的servlet做网页开发的时候有个web.xml的映射文件，里面有个mapping的标签就是用来做文件映射的。 当你在浏览器上输入URL地址的时候，文件就会根据你写的名称对应到一个java文件，根据java文件里编写的内容显示在浏览器上，就是一个网页，所以网页名字是随便写的，随便起的名字，不管你起的是.php .jsp .do还是其他的什么都对应这个java文件，这个java文件里的代码进行什么操作就干什么，显示一句话还是连接数据库还是跳转到其他页面等等，这个java文件把数据进行封装起到安全和便于管理的作用。其实这个java文件编译过来是.class的一个字节码文件，没有那么一个类似html嵌入标签和代码的网页文件。他与jsp文件区别就是jsp把代码嵌入到html标签中。 还有servlet或者struts中html表单的action中的提交名称对应一个java文件，struts一般是.do的，都和上面一样是映射。","tags":["java"],"categories":["技术"]},{"title":"java框架概述","url":"/tech-notes/the-java-frame-1567927869.html","content":"一、框架的意义\n1.什么是框架？\n框架就是一些类和接口的集合，通过这些类和接口协调来完成一系列的程序实现。有了框架，我们就可以集中精力进行业务逻辑的开发而不用去关心它的技术实现以及一些辅助的业务逻辑。\n说白了，框架就是封装好方便程序员操作的类，使项目的开发更简单，维护起来也更容易。\n框架的本体，实际上是一些jar包和配置文件。\n2.为什么要使用框架？\n框架的优越性在于：\n(1)集中精力完成系统的业务逻辑设计；\n(2)使程序更容易扩展和维护，稳定性更强；\n(3)处理系统很多细节问题，比如安全性问题。\n\n二、框架的使用\n(1)导入相关的jar包\n(2)配置项目配置文件（比如web.xml），让项目用框架处理各种行为\n(3)添加框架配置文件（比如struts-config.xml），设定框架如何处理各种行为（比如接收到某个请求时，调用哪个类处理）\n(4)编写业务逻辑（继承、实现框架中的类、接口），完成具体处理操作。\n\n三、MVC编程架构\n1.什么是MVC？\nMVC是一种编程架构，它强制性的使应用程序的输入、处理和输出分开。使用MVC应用程序被分成三个核心部件：模型、视图、控制器。它们各自处理自己的任务。\nM：Model（模型），业务逻辑。\nV：View（视图），用户界面。\nC：Controller（控制器），协调业务逻辑(M)和用户界面(V)。\n\n2.举例\n最典型的MVC就是JSP + servlet + javabean的模式：\nM：接收控制器（C）传来的指令，完成业务逻辑，进行数据库操作，然后将数据传给【控制器（C）或者视图（V）】\nV：获取【控制器（C）或者模型（M）】传来的数据，将结果渲染到用户界面上。\nC：截获用户请求，调用业务逻辑（M）完成操作（，然后将数据传递给用户界面（V））\n![jpg](http://img.blog.csdn.net/20170716010210698?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNDIwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![jpg](http://img.blog.csdn.net/20170716010148941?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMDAwNDIwNA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n3.主流MVC架构：SSH和SSM\n(1)SSH：Struts2做控制器(C)，Spring管理各层的组件，Hibernate负责持久化层。\n(2)SSM：SpringMVC做控制器(C)，Spring管理各层的组件，MyBatis负责持久化层。\n(3)共同点：\n①Spring依赖注入DI来管理各层的组件。\n②使用面向切面编程AOP管理事物、日志、权限等。\n(4)不同点：\n①Struts2和SpringMVC 控制器(C)控制视图和模型的交互机制的不同，\n②Struts2是Action类级别，SpringMVC是方法级别，更容易实现RESTful风格。\n(5)SSM和SSH不同主要在MVC实现方式，以及ORM持久化方面不同（Hiibernate与Mybatis）。SSM越来越轻量级配置，将注解开发发挥到极致，且ORM实现更加灵活，SQL优化更简便；而SSH较注重配置开发，其中的Hiibernate对JDBC的完整封装更面向对象，对增删改查的数据维护更自动化，但SQL优化方面较弱，且入门门槛稍高。\n\n四、各框架简介【待修改】\n1.Spirng\nSpring提供了管理业务对象的一致方法，并且鼓励了注入对接口编程而不是对类编程的良好习惯。Spring的架构基础是基于使用JavaBean属性的Inversion of Control容器。然而，这仅仅是完整图景中的一部分：Spring在使用IoC容器作为构建完关注所有架构层的完整解决方案方面是独一无二的。\nSpring提供了唯一的数据访问抽象，包括简单和有效率的JDBC框架，极大的改进了效率并且减少了可能的错误。Spring的数据访问架构还集成了Hibernate和其他O/R mapping解决方案。Spring还提供了唯一的事务管理抽象，它能够在各种底层事务管理技术，例如JTA或者JDBC事务提供一个一致的编程模型。Spring提供了一个用标准Java语言编写的AOP框架，它给POJOs提供了声明式的事务管理和其他企业事务–如果你需要–还能实现你自己的aspects。这个框架足够强大，使得应用程序能够抛开EJB的复杂性，同时享受着和传统EJB相关的关键服务。Spring还提供了可以和IoC容器集成的强大而灵活的MVC Web框架。\n\n2.Struts2\nStruts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小\n\n3.Hibernate\nHibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序实用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。\n\n4.SpringMVC\nM 代表 模型（Model）\n模型是什么呢？ 模型就是数据，就是 dao,bean\nV 代表 视图（View）\n视图是什么呢？ 就是网页, JSP，用来展示模型中的数据\nC 代表 控制器（controller)\n控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色。\n\n5.Mybatis\nMyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。","tags":["java"],"categories":["技术"]},{"title":"这周太忙停一周","url":"/humanities/a-busy-week-1567337597.html","content":"偶尔摸个鱼","tags":["碎碎念"],"categories":["人文"]},{"title":"ConnectionPool构造方法和初始化","url":"/tech-notes/the-way-connectionpool-1566740339.html","content":"1. ConnectionPool() 构造方法约定了这个连接池一共有多少连接\n\n2. 在init() 初始化方法中，创建了size条连接。 注意，这里不能使用try-with-resource这种自动关闭连接的方式，因为连接恰恰需要保持不关闭状态，供后续循环使用\n\n3. getConnection， 判断是否为空，如果是空的就wait等待，否则就借用一条连接出去\n\n4. returnConnection， 在使用完毕后，归还这个连接到连接池，并且在归还完毕后，调用notifyAll，通知那些等待的线程，有新的连接可以借用了\n注：连接池设计用到了多线程的wait和notifyAll\n```\npackage jdbc;\n  \nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n  \npublic class ConnectionPool {\n  \n    List<Connection> cs = new ArrayList<Connection>();\n  \n    int size;\n  \n    public ConnectionPool(int size) {\n        this.size = size;\n        init();\n    }\n  \n    public void init() {\n          \n        //这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是\"活\"的，不要被自动关闭了\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            for (int i = 0; i < size; i++) {\n                Connection c = DriverManager\n                        .getConnection(\"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8\", \"root\", \"admin\");\n  \n                cs.add(c);\n  \n            }\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (SQLException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n  \n    public synchronized Connection getConnection() {\n        while (cs.isEmpty()) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        Connection c = cs.remove(0);\n        return c;\n    }\n  \n    public synchronized void returnConnection(Connection c) {\n        cs.add(c);\n        this.notifyAll();\n    }\n  \n}\n```\n相关连接[数据库连接池](http://how2j.cn/k/jdbc/jdbc-connection-pool/610.html#nowhere)","tags":["mysql"],"categories":["技术"]},{"title":"什么是事务","url":"/tech-notes/the-affair-1566303755.html","content":"## 事务就是对一组sql语句进行统一的提交或回滚操作\n### 在事务中的多个操作，要么都成功，要么都失败\n### 1.JDBC\n通过 c.setAutoCommit(false);关闭**自动提交**\n使用 c.commit();进行**手动提交**\n在22行-35行之间的数据库操作，就处于同一个事务当中，要么都成功，要么都失败\n所以，虽然第一条SQL语句是可以执行的，但是第二条SQL语句有错误，其结果就是两条SQL语句**都没有被提交**。 除非两条SQL语句都是正确的\n```\npackage jdbc;\n  \nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n  \npublic class TestJDBC {\n    public static void main(String[] args) {\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n \n        try (Connection c = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8\",\"root\", \"admin\");\n            Statement s = c.createStatement();) {\n  \n            // 有事务的前提下\n            // 在事务中的多个操作，要么都成功，要么都失败\n  \n            c.setAutoCommit(false);\n  \n            // 加血的SQL\n            String sql1 = \"update hero set hp = hp +1 where id = 22\";\n            s.execute(sql1);\n  \n            // 减血的SQL\n            // 不小心写错写成了 updata(而非update)\n  \n            String sql2 = \"updata hero set hp = hp -1 where id = 22\";\n            s.execute(sql2);\n  \n            // 手动提交\n            c.commit();\n  \n        } catch (SQLException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n  \n    }\n}\n```\n### 2.spring\n-spring中的事务 作为 局部事务 ， 配置方式依赖于持久层使用的技术 \nspring整合jdbc \nspring整合hibernate\n\n-spring中即提供了编程式事务的管理方式，也提供了声明式事务的管理方式：\n【**编程式事务** TransactionTemplate\n\n模板类 将事务的管理过程封装模板类中】 \n\n【**声明式事务** AOP\n提供根接口 PlatFormTransactionManager 事务管理器接口 \n用于描述spring中事务如何管理[如何创建、如何提交、如何回滚] 】\n\n-声明式事务 \n底层采用AOP技术实现，将事务管理过程(创建、提交、回滚)封装在一个事务通知bean[AfterAdvice ThrowsAdvice]中; \n通过在ioc容器中配置切入点的方式，将这个事务通知bean提供的事务管理功能引用给需要事务的核心业务逻辑方法(DAO)\n相关连接[Spring中如何使用事务？](https://www.cnblogs.com/xym4869/p/8976949.html)","tags":["java"],"categories":["技术"]},{"title":"比较execute、executeUpdate的区别","url":"/tech-notes/the-different-execute-1565790905.html","content":"# 一、比较execute、executeUpdate的区别\n## 1.相同点：\n   不同1：\n\n        execute可以执行查询语句，然后通过getResultSet，把结果集取出来。\n\n        executeUpdate不能执行查询语句。\n\n    不同2:\n\n        execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等。\n\n        executeUpdate返回的是int，表示有多少条数据受到了影响。\n\n运行示例：\n```\nimport java.sql.*;\n \n/**\n * @author 15643\n * 比较execute和executeUpdate的区别\n */\npublic class ExcuteAndUpdate {\n\tpublic static void main(String[] args) {\n\t\tString driverName = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\";\n\t\tString dbUrl = \"jdbc:sqlserver://localhost:1433;DatabaseName=SC\";\n\t\tString userName = \"test\";\n\t\tString userPwd = \"test\";\n\t\tConnection conn = null;\n\t\tPreparedStatement pStmt = null;\n\t\ttry {\n\t\t\tClass.forName(driverName);\n\t\t\tconn = DriverManager.getConnection(dbUrl, userName, userPwd);\n\t\t\tString sql = \"update course set coursecredit = 5 where courseno like ?\";\n\t\t\tpStmt = conn.prepareStatement(sql);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\ttry {\n\t\t\tpStmt.setString(1, \"101_\");\n\t\t\t// executeUpdate返回的是int，表示有多少条数据受到了影响\n\t\t\tint cnt = pStmt.executeUpdate();\n\t\t\t// execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等\n\t\t\tboolean isSelect = pStmt.execute();\n\t\t\tSystem.out.println(\"修改的条数：\" + cnt);\n\t\t\tSystem.out.println(\"是否查询语句:\" + isSelect);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\ttry {\n\t\t\tif (pStmt != null)\n\t\t\t\tpStmt.close();\n\t\t\tif (conn != null)\n\t\t\t\tconn.close();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n运行截图：![jpg](https://img-blog.csdn.net/20180604203925360)\n# 二、事务\n## 1.事务简介\n-概念\n例如：在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序。\n-特性\n事务是恢复和并发控制的基本单位。\n事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。\n        原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。\n        一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n        隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n        持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。\n## 2.实例\n   假设业务操作是：对某同学的一科成绩减去5分，另一科成绩加上5分，预期结果是该同学的总分不变。\n但是在实际操作中把加分的语句不小心写错写成了 updata(而非update)----在没有使用事务的情况下，最后结果显而易见是总分增加了5分，而非期望的不变。那么，要如何操作才会避免这种事情发生呢？ \n   **使用事务：** \n   通过 c.setAutoCommit(false);关闭自动提交 使用 c.commit();进行手动提交 红色的代码就处于同一个事务当中，它们要么都成功，要么都失败 所以，虽然第一条SQL语句是可以执行的，但是第二条SQL语句有错误，其结果就是两条SQL语句都没有被提交。 除非两条SQL语句都是正确的\n\n```\n/**\n * @author 15643\n *\t事务的操作\n */\nimport java.sql.*;\n \npublic class Transation {\n\tpublic static void main(String[] args) {\n\t\tString driverName = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\";\n\t\tString dbUrl = \"jdbc:sqlserver://localhost:1433;DatabaseName=SC\";\n\t\tString userName = \"test\";\n\t\tString userPwd = \"test\";\n\t\tConnection conn = null;\n\t\tStatement stmt = null;\n\t\tResultSet rs0 = null;\n\t\ttry {\n\t\t\tClass.forName(driverName);\n\t\t\tconn = DriverManager.getConnection(dbUrl, userName, userPwd);\n\t\t\tString sql0 = \"select finalscore from score where studentno = '10403201'\";\n\t\t\tstmt = conn.createStatement();\n\t\t\trs0 = stmt.executeQuery(sql0);//提取更新之前的数据\n\t\t\twhile(rs0.next()) {\n\t\t\t\tSystem.out.println(rs0.getDouble(1));\n\t\t\t}\n\t\t\tconn.setAutoCommit(false);// 关闭自动提交\n\t\t\tString sql1 = \"update score set finalscore = finalscore + 5 where studentno = '10403201'\";\n\t\t\tString sql2 = \"updata score set finalscore = finalscore - 5 where studentno = '10403201'\";\n\t\t\tstmt.execute(sql1);\n\t\t\tstmt.execute(sql2);\n\t\t\tconn.commit();//手动提交事务\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\ttry {\n\t\t\tif (stmt != null)\n\t\t\t\tstmt.close();\n\t\t\tif (conn != null)\n\t\t\t\tconn.close();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n来源[JDBC（四）之事务以及比较execute、executeUpdate的区别](https://blog.csdn.net/CNAHYZ/article/details/80572718)","tags":["java"],"categories":["技术"]},{"title":"Tomcat：8080端口被Oracle XE占用问题的解决","url":"/tech-notes/the-problem-Oracle-1565449247.html","content":"装上Oracle XE版本数据库后，再在Eclipse中运行Web项目时，提示启动Tomcat时遇到了错误，如下图所示：\n![jpg](https://img-blog.csdn.net/20170903145814710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXV0ZWJlbmJlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n经过搜索得知出现此错误是由于我装的Oracle XE版本数据库占用了Tomcat的8080端口，导致每次电脑启动后，我都需要先手动关闭掉被Oracle占用的8080端口，才能使Tomcat正常使用。为了解决这个问题，我把Oracle占用的端口从8080改为8081，具体操作如下：\n\n1.打开Oracle的SQL命令行 \n![jpg](https://img-blog.csdn.net/20170903151019979?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXV0ZWJlbmJlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n2.在SQL命令行中输入以下代码来修改端口\n```\nSQL> -- Change the HTTP/WEBDAV port from 8080 to 8081\nSQL> call dbms_xdb.cfg_update(updateXML(\n2      dbms_xdb.cfg_get()\n3      , '/xdbconfig/sysconfig/protocolconfig/httpconfig/http-port/text()'\n4      , 8081))\n5  /\n调用完成。\nSQL> -- Change the FTP port from 2100 to 2111\nSQL> call dbms_xdb.cfg_update(updateXML(\n2       dbms_xdb.cfg_get()\n3       , '/xdbconfig/sysconfig/protocolconfig/ftpconfig/ftp-port/text()'\n4       , 2111))\n5  /\n调用完成。\nSQL> COMMIT;\n提交完成。\nSQL> EXEC dbms_xdb.cfg_refresh;\nPL/SQL 过程已成功完成。\n```\n**有一点需要注意：在输入上述代码块之前，需要先连接上数据库，否则会提示“SP2-0640：未连接”**，SQL命令行连接代为```conn sys/密码 as sysdba;```回车，提示已连接，问题解决。如下图所示\n![jpg](https://img-blog.csdn.net/20170903152605531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXV0ZWJlbmJlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n完整的操作过程如下图：\n![jpg](https://img-blog.csdn.net/20170903153423613?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXV0ZWJlbmJlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n相关连接[Tomcat：8080端口被Oracle XE占用问题的解决](https://blog.csdn.net/mutebenben/article/details/77822328)","tags":["java"],"categories":["技术"]},{"title":"Java泛型中extends和super的区别","url":"/tech-notes/the-different-genericity-1565184981.html","content":"## <? extends T>和<? super T>\n\n<? extends T>和<? super T>是Java泛型中的“**通配符（Wildcards)**”和“**边界（Bounds）**”的概念。\n\n- <? extends T>：是指 “**上界通配符**（Upper Bounds Wildcards）”\n- <? super T>：是指 “**下界通配符**（Lower Bounds Wildcards）”\n\n### 为什么要用通配符和边界？\n使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。\n```\nclass Fruit {}\nclass Apple extends Fruit {}\n```\n然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：set( )和get( )方法\n```\nclass Plate<T>{\n    private T item;\n    public Plate(T t){item=t;}\n    public void set(T t){item=t;}\n    public T get(){return item;}\n}\n```\n现在我定义一个“水果盘子”，逻辑上水果盘子当然可以装苹果\n```\nPlate<Fruit> p=new Plate<Apple>(new Apple());\n```\n但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。\n```\nerror: incompatible types: Plate<Apple> cannot be converted to Plate<Fruit>\n```\n所以我的尴尬症就犯了。实际上，编译器脑袋里认定的逻辑是这样的：\n\n- **苹果 IS-A 水果**\n- **装苹果的盘子 NOT-IS-A 装水果的盘子**\n所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不可以把Plate的引用传递给Plate。\n\n为了让泛型用起来更舒服，Sun的大脑袋们就想出了<? extends T>和<? super T>的办法，来让”水果盘子“和”苹果盘子“之间发生关系。\n### 什么是上界？\n下面代码就是“上界通配符（Upper Bounds Wildcards）”：\n```\nPlate<？ extends Fruit>\n```\n翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。这和我们人类的逻辑就比较接近了。Plate<？ extends Fruit>和Plate<Apple>最大的区别就是：Plate<？ extends Fruit>是Plate<Fruit>以及Plate<Apple>的基类。直接的好处就是，我们可以用“苹果盘子”给“水果盘子”赋值了。\n```\nPlate<? extends Fruit> p=new Plate<Apple>(new Apple());\n```\n如果把Fruit和Apple的例子再扩展一下，食物分成水果和肉类，水果有苹果和香蕉，肉类有猪肉和牛肉，苹果还有两种青苹果和红苹果\n```\n//Lev 1\nclass Food{}\n\n//Lev 2\nclass Fruit extends Food{}\nclass Meat extends Food{}\n\n//Lev 3\nclass Apple extends Fruit{}\nclass Banana extends Fruit{}\nclass Pork extends Meat{}\nclass Beef extends Meat{}\n\n//Lev 4\nclass RedApple extends Apple{}\nclass GreenApple extends Apple{}\n```\n在这个体系中，下界通配符 Plate<？ extends Fruit> 覆盖下图中蓝色的区域\n![jpg](https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004120143-1731938777.png)\n### 什么是下界？\n相对应的，“下界通配符（Lower Bounds Wildcards）”：\n```\nPlate<？ super Fruit>\n```\n表达的就是相反的概念：一个能放水果以及一切是水果基类的盘子。Plate<？ super Fruit>是Plate<Fruit>的基类，但不是Plate<Apple>的基类。对应刚才那个例子，Plate<？ super Fruit>覆盖下图中红色的区域。\n![jpg](https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004216471-1377946016.png)\n### 上下界通配符的副作用\n边界让Java不同泛型之间的转换更容易了。但不要忘记，这样的转换也有一定的副作用。那就是容器的部分功能可能失效。\n\n还是以刚才的Plate为例。我们可以对盘子做两件事，往盘子里set()新东西，以及从盘子里get()东西。\n```\nclass Plate<T>{\n    private T item;\n    public Plate(T t){item=t;}\n    public void set(T t){item=t;}\n    public T get(){return item;}\n}\n```\n上界<? extends T>不能往里存，只能往外取\n**<? extends Fruit>会使往盘子里放东西的set( )方法失效。但取东西get( )方法还有效。比如下面例子里两个set()方法，插入Apple和Fruit都报错**\n```\nPlate<? extends Fruit> p=new Plate<Apple>(new Apple());\n    \n//不能存入任何元素\np.set(new Fruit());    //Error\np.set(new Apple());    //Error\n\n//读取出来的东西只能存放在Fruit或它的基类里。\nFruit newFruit1=p.get();\nObject newFruit2=p.get();\nApple newFruit3=p.get();    //Error\n```\n原因是编译器只知道容器内是Fruit或者它的派生类，但具体是什么类型不知道。可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在看到后面用Plate赋值以后，盘子里没有被标上有“苹果”。而是标上一个占位符：CAP#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，代号CAP#1。然后无论是想往里插入Apple或者Meat或者Fruit编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。\n\n所以通配符<?>和类型参数的区别就在于，对编译器来说所有的T都代表同一种类型。比如下面这个泛型方法里，三个T都指代同一个类型，要么都是String，要么都是Integer。\n```\npublic <T> List<T> fill(T... t);\n```\n但通配符<?>没有这种约束，Plate<?>单纯的就表示：盘子里放了一个东西，是什么我不知道。\n\n所以题主问题里的错误就在这里，Plate<？ extends Fruit>里什么都放不进去。\n**下界<? super T>不影响往里存，但往外取只能放在Object对象里\n使用下界<? super Fruit>会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里。set( )方法正常。**\n```\nPlate<? super Fruit> p=new Plate<Fruit>(new Fruit());\n\n//存入元素正常\np.set(new Fruit());\np.set(new Apple());\n\n//读取出来的东西只能存放在Object类里。\nApple newFruit3=p.get();    //Error\nFruit newFruit1=p.get();    //Error\nObject newFruit2=p.get();\n```\n因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然元素是Fruit的基类，那往里存粒度比Fruit小的都可以。但往外读取元素就费劲了，只有所有类的基类Object对象才能装下。但这样的话，元素的类型信息就全部丢失。\n### PECS原则\n最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了：\n- 频繁往外读取内容的，适合用上界Extends。\n- 经常往里插入的，适合用下界Super。\n\n来源[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)","tags":["java"],"categories":["技术"]},{"title":"HashCode原理，为什么HashMap那么快？","url":"/tech-notes/the-Principle-HashCode-1564839206.html","content":"HashCode作为一个算法，简单来说它就是把一串字符串变成一串数字仅此而已\n以下是JavaAPI提供的String的HashCode生成方法\n```\ns[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n```\n我们不需要去理解这个算法，或者叫你去写\n那么问题来了，它跟HashMap有什么关系？\n众所周知，HashMap的特性是键值对，那么键值对背后究竟是怎么存储的呢？\n我们可以通过一个case来理解其中的联系\n设计一个HashMap类(LinkedList)\n>设计一个put(String key,Object value)方法\n\n通过HashCode算法得到key对应的hashcode码，把它作为下标，定位到数组相对应位置\n如果该位置没有数据，则把字符串和对象组合成键值对Entry，再创建一个LinkedList，把键值对，放进LinkedList中，最后把LinkedList 保存在这个位置。\n如果该位置有数据，一定是一个LinkedList,则把字符串和对象组合成键值对Entry，插入到LinkedList后面。\n>设计 Object get(String key) 方法\n\n通过HashCode算法得到key对应的hashcode码，把它作为下标，定位到数组相对应位置\n如果这个位置没有数据，则返回空\n如果这个位置有数据，则挨个比较其中键值对的键-字符串，是否equals，找到匹配的，把键值对的值，返回出去。找不到匹配的，就返回空\n![jpg](https://upload-images.jianshu.io/upload_images/14876243-ff5d3596d2a93cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567/format/webp)\n## 空间换取时间的方法加快效率","tags":["java"],"categories":["技术"]},{"title":"ArrayList与LinkedList的区别","url":"/tech-notes/the-different-collection-1564584613.html","content":"## ArrayList和LinkedList的区别\nArrayList **插入，删除数据慢**\nLinkedList， **插入，删除数据快**\nArrayList是顺序结构，所以**定位很快**，指哪找哪。 就像电影院位置一样，有了电影票，一下就找到位置了。\nLinkedList 是链表结构，就像手里的一串佛珠，要找出第99个佛珠，必须得一个一个的数过去，所以**定位慢**\n\n## 插入数据\n\n```\npackage collection;\n \nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n \npublic class TestCollection {\n    public static void main(String[] args) {\n        List<Integer> l;\n        l = new ArrayList<>();\n        insertFirst(l, \"ArrayList\");\n \n        l = new LinkedList<>();\n        insertFirst(l, \"LinkedList\");\n \n    }\n \n    private static void insertFirst(List<Integer> l, String type) {\n        int total = 1000 * 100;\n        final int number = 5;\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < total; i++) {\n            l.add(0, number);\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"在%s 最前面插入%d条数据，总共耗时 %d 毫秒 %n\", type, total, end - start);\n    }\n \n}\n```\n## 定位数据\n\n```\npackage collection;\n \nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n \npublic class TestCollection {\n    public static void main(String[] args) {\n        List<Integer> l;\n        l = new ArrayList<>();\n        modify(l, \"ArrayList\");\n \n        l = new LinkedList<>();\n        modify(l, \"LinkedList\");\n \n    }\n \n    private static void modify(List<Integer> l, String type) {\n        int total = 100 * 1000;\n        int index = total/2;\n        final int number = 5;\n        //初始化\n        for (int i = 0; i < total; i++) {\n            l.add(number);\n        }\n         \n        long start = System.currentTimeMillis();\n \n        for (int i = 0; i < total; i++) {\n             int n = l.get(index);\n             n++;\n             l.set(index, n);\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"%s总长度是%d，定位到第%d个数据，取出来，加1，再放回去%n 重复%d遍，总共耗时 %d 毫秒 %n\", type,total, index,total, end - start);\n        System.out.println();\n    }\n \n}\n```\n相关连接[ARRAYLIST和LINKEDLIST的区别详解](http://how2j.cn/k/collection/collection-arraylist-vs-linkedlist/690.html#nowhere)","tags":["java"],"categories":["技术"]},{"title":"ArrList与HashSet的区别","url":"/tech-notes/the-different-collection-1564583728.html","content":"## 是否有顺序\nArrayList: 有顺序\nHashSet: 无顺序\n\nHashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。\n以下是**HasetSe源代码**中的部分注释\n```\n/**\n * It makes no guarantees as to the iteration order of the set; \n * in particular, it does not guarantee that the order will remain constant over time. \n*/\n```\n>不保证Set的迭代顺序; 确切的说，在不同条件下，元素的顺序都有可能不一样\n换句话说，同样是插入0-9到HashSet中， 在JVM的不同版本中，看到的顺序都是不一样的。 所以在开发的时候，不能依赖于某种**臆测的顺序**，这个顺序本身是**不稳定的**\n```\npackage collection;\n   \nimport java.util.ArrayList;\nimport java.util.HashSet;\n    \npublic class TestCollection {\n    public static void main(String[] args) {\n           \n        ArrayList<Integer> numberList =new ArrayList<Integer>();\n        //List中的数据按照插入顺序存放\n        System.out.println(\"----------List----------\");\n        System.out.println(\"向List 中插入 9 5 1\");\n        numberList.add(9);\n        numberList.add(5);\n        numberList.add(1);\n        System.out.println(\"List 按照顺序存放数据:\");\n        System.out.println(numberList);\n        System.out.println(\"----------Set----------\");\n        HashSet<Integer> numberSet =new HashSet<Integer>();\n        System.out.println(\"向Set 中插入9 5 1\");\n        //Set中的数据不是按照插入顺序存放\n        numberSet.add(9);\n        numberSet.add(5);\n        numberSet.add(1);\n        System.out.println(\"Set 不是按照顺序存放数据:\");\n        System.out.println(numberSet);\n           \n    }\n}\n```\n## List中的数据可以重复\nSet中的数据不能够重复\n重复判断标准是:\n首先看hashcode是否相同\n如果hashcode不同，则认为是不同数据\n如果hashcode相同，再比较equals，如果equals相同，则是相同数据，否则是不同数据\n```\npackage collection;\n   \nimport java.util.ArrayList;\nimport java.util.HashSet;\n    \npublic class TestCollection {\n    public static void main(String[] args) {\n           \n        ArrayList<Integer> numberList =new ArrayList<Integer>();\n        //List中的数据可以重复\n        System.out.println(\"----------List----------\");\n        System.out.println(\"向List 中插入 9 9\");\n        numberList.add(9);\n        numberList.add(9);\n        System.out.println(\"List 中出现两个9:\");\n        System.out.println(numberList);\n        System.out.println(\"----------Set----------\");\n        HashSet<Integer> numberSet =new HashSet<Integer>();\n        System.out.println(\"向Set 中插入9 9\");\n        //Set中的数据不能重复\n        numberSet.add(9);\n        numberSet.add(9);\n        System.out.println(\"Set 中只会保留一个9:\");\n        System.out.println(numberSet);\n           \n    }\n}\n```\n相关连接[JAVA ARRAYLIST和HASHSET的区别](http://how2j.cn/k/collection/collection-arraylist-vs-hashset/367.html)","tags":["java"],"categories":["技术"]},{"title":"二叉树排序-遍历","url":"/tech-notes/the-practise-ArrayList-1564242141.html","content":"\n利用二叉树把**排好序的数据**，遍历成我们常用的List或者数组的形式\n\n二叉树的遍历分左序，中序，右序\n左序即： 中间的数遍历后放在左边\n中序即： 中间的数遍历后放在中间\n右序即： 中间的数遍历后放在右边\n如图所见，我们希望遍历后的结果是从小到大的，所以应该采用中序遍历\n![jpg](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2595362298,2802985994&fm=26&gp=0.jpg)\n\n```\npackage collection;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Node {\n    // 左子节点\n    public Node leftNode;\n    // 右子节点\n    public Node rightNode;\n  \n    // 值\n    public Object value;\n  \n    // 插入 数据\n    public void add(Object v) {\n        // 如果当前节点没有值，就把数据放在当前节点上\n        if (null == value)\n            value = v;\n  \n        // 如果当前节点有值，就进行判断，新增的值与当前值的大小关系\n        else {\n            // 新增的值，比当前值小或者相同\n             \n            if ((Integer) v -((Integer)value) <= 0) {\n                if (null == leftNode)\n                    leftNode = new Node();\n                leftNode.add(v);\n            }\n            // 新增的值，比当前值大\n            else {\n                if (null == rightNode)\n                    rightNode = new Node();\n                rightNode.add(v);\n            }\n  \n        }\n  \n    }\n```\n以上是二叉树排序，接下来是转换\n```\n // 中序遍历所有的节点\n    public List<Object> values() {\n        List<Object> values = new ArrayList<>();\n  \n        // 左节点的遍历结果\n        if (null != leftNode)\n            values.addAll(leftNode.values());\n  \n        // 当前节点\n        values.add(value);\n  \n        // 右节点的遍历结果\n        if (null != rightNode)\n  \n            values.addAll(rightNode.values());\n  \n        return values;\n    }\n  \n    public static void main(String[] args) {\n  \n        int randoms[] = new int[] { 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 };\n  \n        Node roots = new Node();\n        for (int number : randoms) {\n            roots.add(number);\n        }\n  \n        System.out.println(roots.values());\n  \n    }\n}\n```\n拓展：[几道和「二叉树」有关的算法面试题](https://www.itcodemonkey.com/article/13686.html)","tags":["java"],"categories":["技术"]},{"title":"删除ArrayList中的数据","url":"/tech-notes/the-practise-ArrayList-1564232895.html","content":"\n首先初始化一个Hero集合，里面放100个Hero对象，名称分别是从\nhero 0\nhero 1\nhero 2\n...\nhero 99.\n\n通过遍历的手段，删除掉名字编号是8的倍数的对象\n\n\n>这个练习的考点是，不能够在使用Iterator和增强for循环遍历数据的同时，删除数据，否则会抛出**ConcurrentModificationException**\n\n>解决办法，是准备一个临时容器，专门用来保存需要删除的对象。 然后再删掉\n\n```\npackage collection;\nimport java.util.ArrayList;\nimport java.util.List;\n \nimport charactor.Hero;\n \npublic class TestCollection {\n \n    public static void main(String[] args) {\n        List<Hero> heros = new ArrayList<Hero>();\n \n        // 放100个Hero进入容器\n        for (int i = 0; i < 100; i++) {\n            heros.add(new Hero(\"hero name \" + i));\n        }\n \n        //准备一个容器，专门用来装要删除的对象\n        List<Hero> deletingHeros = new ArrayList<>();\n \n        for (Hero h : heros) {\n            int id = Integer.parseInt(h.name.substring(10));\n            if (0 == id % 8)\n                deletingHeros.add(h);\n        }\n        for (Hero h : deletingHeros) {\n            heros.remove(h);\n        }\n    //heros.removeAll(deletingHeros); //直接通过removeAll删除多个Hero对象\n        System.out.println(heros);\n    }\n \n}\n```","tags":["java"],"categories":["技术"]},{"title":"其他测试","url":"/others/the-test-others-1563626682.html","content":"\n其他分支测试","tags":["hexo"],"categories":["其他"]},{"title":"开始记录-学习日记","url":"/humanities/first-daliy-note-1563625610.html","content":"\n# 第一次记录\n\n\n\n## 关于学习记录\n\n以后随机抽时间发布，但每星期至少两篇对于学习的感悟，以及值得记录的知识点。","tags":["碎碎念"],"categories":["人文"]},{"title":"hexo常用语句","url":"/tech-notes/the-hexo-normal-1563374311.html","content":"\nHexo 约有二十个命令，但普通用户经常使用的大概只有下列几个:\n\n# hexo s\n`hexo s`\n\n启动本地服务器，用于预览主题。默认地址： http://localhost:4000/\n\n- hexo s 是 hexo server 的缩写，命令效果一致；\n- 预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；\n- 对 Hexo 根目录 -config.yml 的修改，需要重启；\n\n\n# hexo g\n`hexo g`\n\n清除缓存文件db.json 和已生成的静态文件public\n\n# hexo d\n`hexo d`\n\n是hexo deploy的简写形式，部署静态文件到设定的仓库\n\n# hexo clean && hexo g && hexo d\n`hexo clean && hexo g && hexo d`\n\n常用的组合命令，清除缓存，生成静态文件，并部署到指定仓库\n","tags":["hexo"],"categories":["技术"]},{"title":"测试2","url":"/tech-notes/the-test-normal-1563374174.html","content":"\n123123","tags":["练习"],"categories":["技术"]},{"title":"测试","url":"/tech-notes/the-test-null.html","tags":["练习"],"categories":["技术"]},{"title":"hexo练习","url":"/tech-notes/first-practise-null.html","content":"# 第一次练习\n\n熟悉相关语句","tags":["练习"],"categories":["技术"]},{"title":"hexo发布文章","url":"/tech-notes/first-hexo-undefined.html","content":"# 一级标题\n## 二级标题\n### 三级标题\n\n> 这个是引用\n\n--------------------\n\n*斜体*\n\n**加粗**\n\n![jpg](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1561983930916&di=c5c74316b89e531f12f7acfacc518d43&imgtype=0&src=http%3A%2F%2Fg.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F203fb80e7bec54e7f0e0839fb7389b504fc26a27.jpg)\n\n[百度](https://www.baidu.com)\n\n```c\nvar i = 0;\n```\n- 列表\n- 列表\n- 列表\n\n1.列表\n2.列表\n3.列表\n\n|表头|表头|表头|\n|:-:|:-|-:|\n|内容|内容|内容|\n|内容|内容|内容|\n\n~~删除线~~\n\n`#` 我打算在文字中加那些","tags":["hexo"],"categories":["技术"]},{"title":"QA - 帮助中心","url":"/help/index.html","content":"\n# Q: 这网站怎么弄的，还挺好看的啊？"},{"title":"为何建站&为何写作","url":"/about/index.html","content":"\n# 为何建站"},{"title":"优秀的资源","url":"/links/index.html","content":"\n# 学习网站"}]