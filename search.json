[{"title":"HashCode原理，为什么HashMap那么快？","url":"/tech-notes/the-Principle-HashCode-1564839206.html","content":"HashCode作为一个算法，简单来说它就是把一串字符串变成一串数字仅此而已\n以下是JavaAPI提供的String的HashCode生成方法\n```\ns[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n```\n我们不需要去理解这个算法，或者叫你去写\n那么问题来了，它跟HashMap有什么关系？\n众所周知，HashMap的特性是键值对，那么键值对背后究竟是怎么存储的呢？\n我们可以通过一个case来理解其中的联系\n设计一个HashMap类(LinkedList)\n>设计一个put(String key,Object value)方法\n\n通过HashCode算法得到key对应的hashcode码，把它作为下标，定位到数组相对应位置\n如果该位置没有数据，则把字符串和对象组合成键值对Entry，再创建一个LinkedList，把键值对，放进LinkedList中，最后把LinkedList 保存在这个位置。\n如果该位置有数据，一定是一个LinkedList,则把字符串和对象组合成键值对Entry，插入到LinkedList后面。\n>设计 Object get(String key) 方法\n\n通过HashCode算法得到key对应的hashcode码，把它作为下标，定位到数组相对应位置\n如果这个位置没有数据，则返回空\n如果这个位置有数据，则挨个比较其中键值对的键-字符串，是否equals，找到匹配的，把键值对的值，返回出去。找不到匹配的，就返回空\n![jpg](https://upload-images.jianshu.io/upload_images/14876243-ff5d3596d2a93cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567/format/webp)\n## 空间换取时间的方法加快效率","tags":["java"],"categories":["技术"]},{"title":"ArrayList与LinkedList的区别","url":"/tech-notes/the-different-collection-1564584613.html","content":"## ArrayList和LinkedList的区别\nArrayList **插入，删除数据慢**\nLinkedList， **插入，删除数据快**\nArrayList是顺序结构，所以**定位很快**，指哪找哪。 就像电影院位置一样，有了电影票，一下就找到位置了。\nLinkedList 是链表结构，就像手里的一串佛珠，要找出第99个佛珠，必须得一个一个的数过去，所以**定位慢**\n\n## 插入数据\n\n```\npackage collection;\n \nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n \npublic class TestCollection {\n    public static void main(String[] args) {\n        List<Integer> l;\n        l = new ArrayList<>();\n        insertFirst(l, \"ArrayList\");\n \n        l = new LinkedList<>();\n        insertFirst(l, \"LinkedList\");\n \n    }\n \n    private static void insertFirst(List<Integer> l, String type) {\n        int total = 1000 * 100;\n        final int number = 5;\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < total; i++) {\n            l.add(0, number);\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"在%s 最前面插入%d条数据，总共耗时 %d 毫秒 %n\", type, total, end - start);\n    }\n \n}\n```\n## 定位数据\n\n```\npackage collection;\n \nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n \npublic class TestCollection {\n    public static void main(String[] args) {\n        List<Integer> l;\n        l = new ArrayList<>();\n        modify(l, \"ArrayList\");\n \n        l = new LinkedList<>();\n        modify(l, \"LinkedList\");\n \n    }\n \n    private static void modify(List<Integer> l, String type) {\n        int total = 100 * 1000;\n        int index = total/2;\n        final int number = 5;\n        //初始化\n        for (int i = 0; i < total; i++) {\n            l.add(number);\n        }\n         \n        long start = System.currentTimeMillis();\n \n        for (int i = 0; i < total; i++) {\n             int n = l.get(index);\n             n++;\n             l.set(index, n);\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"%s总长度是%d，定位到第%d个数据，取出来，加1，再放回去%n 重复%d遍，总共耗时 %d 毫秒 %n\", type,total, index,total, end - start);\n        System.out.println();\n    }\n \n}\n```\n相关连接[ARRAYLIST和LINKEDLIST的区别详解](http://how2j.cn/k/collection/collection-arraylist-vs-linkedlist/690.html#nowhere)","tags":["java"],"categories":["技术"]},{"title":"ArrList与HashSet的区别","url":"/tech-notes/the-different-collection-1564583728.html","content":"## 是否有顺序\nArrayList: 有顺序\nHashSet: 无顺序\n\nHashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。\n以下是**HasetSe源代码**中的部分注释\n```\n/**\n * It makes no guarantees as to the iteration order of the set; \n * in particular, it does not guarantee that the order will remain constant over time. \n*/\n```\n>不保证Set的迭代顺序; 确切的说，在不同条件下，元素的顺序都有可能不一样\n换句话说，同样是插入0-9到HashSet中， 在JVM的不同版本中，看到的顺序都是不一样的。 所以在开发的时候，不能依赖于某种**臆测的顺序**，这个顺序本身是**不稳定的**\n```\npackage collection;\n   \nimport java.util.ArrayList;\nimport java.util.HashSet;\n    \npublic class TestCollection {\n    public static void main(String[] args) {\n           \n        ArrayList<Integer> numberList =new ArrayList<Integer>();\n        //List中的数据按照插入顺序存放\n        System.out.println(\"----------List----------\");\n        System.out.println(\"向List 中插入 9 5 1\");\n        numberList.add(9);\n        numberList.add(5);\n        numberList.add(1);\n        System.out.println(\"List 按照顺序存放数据:\");\n        System.out.println(numberList);\n        System.out.println(\"----------Set----------\");\n        HashSet<Integer> numberSet =new HashSet<Integer>();\n        System.out.println(\"向Set 中插入9 5 1\");\n        //Set中的数据不是按照插入顺序存放\n        numberSet.add(9);\n        numberSet.add(5);\n        numberSet.add(1);\n        System.out.println(\"Set 不是按照顺序存放数据:\");\n        System.out.println(numberSet);\n           \n    }\n}\n```\n## List中的数据可以重复\nSet中的数据不能够重复\n重复判断标准是:\n首先看hashcode是否相同\n如果hashcode不同，则认为是不同数据\n如果hashcode相同，再比较equals，如果equals相同，则是相同数据，否则是不同数据\n```\npackage collection;\n   \nimport java.util.ArrayList;\nimport java.util.HashSet;\n    \npublic class TestCollection {\n    public static void main(String[] args) {\n           \n        ArrayList<Integer> numberList =new ArrayList<Integer>();\n        //List中的数据可以重复\n        System.out.println(\"----------List----------\");\n        System.out.println(\"向List 中插入 9 9\");\n        numberList.add(9);\n        numberList.add(9);\n        System.out.println(\"List 中出现两个9:\");\n        System.out.println(numberList);\n        System.out.println(\"----------Set----------\");\n        HashSet<Integer> numberSet =new HashSet<Integer>();\n        System.out.println(\"向Set 中插入9 9\");\n        //Set中的数据不能重复\n        numberSet.add(9);\n        numberSet.add(9);\n        System.out.println(\"Set 中只会保留一个9:\");\n        System.out.println(numberSet);\n           \n    }\n}\n```\n相关连接[JAVA ARRAYLIST和HASHSET的区别](http://how2j.cn/k/collection/collection-arraylist-vs-hashset/367.html)","tags":["java"],"categories":["技术"]},{"title":"二叉树排序-遍历","url":"/tech-notes/the-practise-ArrayList-1564242141.html","content":"\n利用二叉树把**排好序的数据**，遍历成我们常用的List或者数组的形式\n\n二叉树的遍历分左序，中序，右序\n左序即： 中间的数遍历后放在左边\n中序即： 中间的数遍历后放在中间\n右序即： 中间的数遍历后放在右边\n如图所见，我们希望遍历后的结果是从小到大的，所以应该采用中序遍历\n![jpg](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2595362298,2802985994&fm=26&gp=0.jpg)\n\n```\npackage collection;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Node {\n    // 左子节点\n    public Node leftNode;\n    // 右子节点\n    public Node rightNode;\n  \n    // 值\n    public Object value;\n  \n    // 插入 数据\n    public void add(Object v) {\n        // 如果当前节点没有值，就把数据放在当前节点上\n        if (null == value)\n            value = v;\n  \n        // 如果当前节点有值，就进行判断，新增的值与当前值的大小关系\n        else {\n            // 新增的值，比当前值小或者相同\n             \n            if ((Integer) v -((Integer)value) <= 0) {\n                if (null == leftNode)\n                    leftNode = new Node();\n                leftNode.add(v);\n            }\n            // 新增的值，比当前值大\n            else {\n                if (null == rightNode)\n                    rightNode = new Node();\n                rightNode.add(v);\n            }\n  \n        }\n  \n    }\n```\n以上是二叉树排序，接下来是转换\n```\n // 中序遍历所有的节点\n    public List<Object> values() {\n        List<Object> values = new ArrayList<>();\n  \n        // 左节点的遍历结果\n        if (null != leftNode)\n            values.addAll(leftNode.values());\n  \n        // 当前节点\n        values.add(value);\n  \n        // 右节点的遍历结果\n        if (null != rightNode)\n  \n            values.addAll(rightNode.values());\n  \n        return values;\n    }\n  \n    public static void main(String[] args) {\n  \n        int randoms[] = new int[] { 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 };\n  \n        Node roots = new Node();\n        for (int number : randoms) {\n            roots.add(number);\n        }\n  \n        System.out.println(roots.values());\n  \n    }\n}\n```\n拓展：[几道和「二叉树」有关的算法面试题](https://www.itcodemonkey.com/article/13686.html)","tags":["java"],"categories":["技术"]},{"title":"删除ArrayList中的数据","url":"/tech-notes/the-practise-ArrayList-1564232895.html","content":"\n首先初始化一个Hero集合，里面放100个Hero对象，名称分别是从\nhero 0\nhero 1\nhero 2\n...\nhero 99.\n\n通过遍历的手段，删除掉名字编号是8的倍数的对象\n\n\n>这个练习的考点是，不能够在使用Iterator和增强for循环遍历数据的同时，删除数据，否则会抛出**ConcurrentModificationException**\n\n>解决办法，是准备一个临时容器，专门用来保存需要删除的对象。 然后再删掉\n\n```\npackage collection;\nimport java.util.ArrayList;\nimport java.util.List;\n \nimport charactor.Hero;\n \npublic class TestCollection {\n \n    public static void main(String[] args) {\n        List<Hero> heros = new ArrayList<Hero>();\n \n        // 放100个Hero进入容器\n        for (int i = 0; i < 100; i++) {\n            heros.add(new Hero(\"hero name \" + i));\n        }\n \n        //准备一个容器，专门用来装要删除的对象\n        List<Hero> deletingHeros = new ArrayList<>();\n \n        for (Hero h : heros) {\n            int id = Integer.parseInt(h.name.substring(10));\n            if (0 == id % 8)\n                deletingHeros.add(h);\n        }\n        for (Hero h : deletingHeros) {\n            heros.remove(h);\n        }\n    //heros.removeAll(deletingHeros); //直接通过removeAll删除多个Hero对象\n        System.out.println(heros);\n    }\n \n}\n```","tags":["java"],"categories":["技术"]},{"title":"其他测试","url":"/others/the-test-others-1563626682.html","content":"\n其他分支测试","tags":["hexo"],"categories":["其他"]},{"title":"开始记录-学习日记","url":"/humanities/first-daliy-note-1563625610.html","content":"\n# 第一次记录\n\n\n\n## 关于学习记录\n\n以后随机抽时间发布，但每星期至少两篇对于学习的感悟，以及值得记录的知识点。","tags":["碎碎念"],"categories":["人文"]},{"title":"hexo常用语句","url":"/tech-notes/the-hexo-normal-1563374311.html","content":"\nHexo 约有二十个命令，但普通用户经常使用的大概只有下列几个:\n\n# hexo s\n`hexo s`\n\n启动本地服务器，用于预览主题。默认地址： http://localhost:4000/\n\n- hexo s 是 hexo server 的缩写，命令效果一致；\n- 预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；\n- 对 Hexo 根目录 -config.yml 的修改，需要重启；\n\n\n# hexo g\n`hexo g`\n\n清除缓存文件db.json 和已生成的静态文件public\n\n# hexo d\n`hexo d`\n\n是hexo deploy的简写形式，部署静态文件到设定的仓库\n\n# hexo clean && hexo g && hexo d\n`hexo clean && hexo g && hexo d`\n\n常用的组合命令，清除缓存，生成静态文件，并部署到指定仓库\n","tags":["hexo"],"categories":["技术"]},{"title":"测试2","url":"/tech-notes/the-test-normal-1563374174.html","content":"\n123123","tags":["练习"],"categories":["技术"]},{"title":"测试","url":"/tech-notes/the-test-null.html","tags":["练习"],"categories":["技术"]},{"title":"hexo练习","url":"/tech-notes/first-practise-null.html","content":"# 第一次练习\n\n熟悉相关语句","tags":["练习"],"categories":["技术"]},{"title":"hexo发布文章","url":"/tech-notes/first-hexo-undefined.html","content":"# 一级标题\n## 二级标题\n### 三级标题\n\n> 这个是引用\n\n--------------------\n\n*斜体*\n\n**加粗**\n\n![jpg](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1561983930916&di=c5c74316b89e531f12f7acfacc518d43&imgtype=0&src=http%3A%2F%2Fg.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F203fb80e7bec54e7f0e0839fb7389b504fc26a27.jpg)\n\n[百度](https://www.baidu.com)\n\n```c\nvar i = 0;\n```\n- 列表\n- 列表\n- 列表\n\n1.列表\n2.列表\n3.列表\n\n|表头|表头|表头|\n|:-:|:-|-:|\n|内容|内容|内容|\n|内容|内容|内容|\n\n~~删除线~~\n\n`#` 我打算在文字中加那些","tags":["hexo"],"categories":["技术"]},{"title":"为何建站&为何写作","url":"/about/index.html","content":"\n# 为何建站"},{"title":"QA - 帮助中心","url":"/help/index.html","content":"\n# Q: 这网站怎么弄的，还挺好看的啊？"},{"title":"优秀的资源","url":"/links/index.html","content":"\n# 学习网站"}]