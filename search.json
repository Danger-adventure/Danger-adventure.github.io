[{"title":"这周太忙停一周","url":"/humanities/a-busy-week-1567337597.html","content":"偶尔摸个鱼","tags":["碎碎念"],"categories":["人文"]},{"title":"ConnectionPool构造方法和初始化","url":"/tech-notes/the-way-connectionpool-1566740339.html","content":"1. ConnectionPool() 构造方法约定了这个连接池一共有多少连接\n\n2. 在init() 初始化方法中，创建了size条连接。 注意，这里不能使用try-with-resource这种自动关闭连接的方式，因为连接恰恰需要保持不关闭状态，供后续循环使用\n\n3. getConnection， 判断是否为空，如果是空的就wait等待，否则就借用一条连接出去\n\n4. returnConnection， 在使用完毕后，归还这个连接到连接池，并且在归还完毕后，调用notifyAll，通知那些等待的线程，有新的连接可以借用了\n注：连接池设计用到了多线程的wait和notifyAll\n```\npackage jdbc;\n  \nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\n  \npublic class ConnectionPool {\n  \n    List<Connection> cs = new ArrayList<Connection>();\n  \n    int size;\n  \n    public ConnectionPool(int size) {\n        this.size = size;\n        init();\n    }\n  \n    public void init() {\n          \n        //这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是\"活\"的，不要被自动关闭了\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            for (int i = 0; i < size; i++) {\n                Connection c = DriverManager\n                        .getConnection(\"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8\", \"root\", \"admin\");\n  \n                cs.add(c);\n  \n            }\n        } catch (ClassNotFoundException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        } catch (SQLException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n  \n    public synchronized Connection getConnection() {\n        while (cs.isEmpty()) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n        Connection c = cs.remove(0);\n        return c;\n    }\n  \n    public synchronized void returnConnection(Connection c) {\n        cs.add(c);\n        this.notifyAll();\n    }\n  \n}\n```\n相关连接[数据库连接池](http://how2j.cn/k/jdbc/jdbc-connection-pool/610.html#nowhere)","tags":["mysql"],"categories":["技术"]},{"title":"什么是事务","url":"/tech-notes/the-affair-1566303755.html","content":"## 事务就是对一组sql语句进行统一的提交或回滚操作\n### 在事务中的多个操作，要么都成功，要么都失败\n### 1.JDBC\n通过 c.setAutoCommit(false);关闭**自动提交**\n使用 c.commit();进行**手动提交**\n在22行-35行之间的数据库操作，就处于同一个事务当中，要么都成功，要么都失败\n所以，虽然第一条SQL语句是可以执行的，但是第二条SQL语句有错误，其结果就是两条SQL语句**都没有被提交**。 除非两条SQL语句都是正确的\n```\npackage jdbc;\n  \nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n  \npublic class TestJDBC {\n    public static void main(String[] args) {\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n \n        try (Connection c = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8\",\"root\", \"admin\");\n            Statement s = c.createStatement();) {\n  \n            // 有事务的前提下\n            // 在事务中的多个操作，要么都成功，要么都失败\n  \n            c.setAutoCommit(false);\n  \n            // 加血的SQL\n            String sql1 = \"update hero set hp = hp +1 where id = 22\";\n            s.execute(sql1);\n  \n            // 减血的SQL\n            // 不小心写错写成了 updata(而非update)\n  \n            String sql2 = \"updata hero set hp = hp -1 where id = 22\";\n            s.execute(sql2);\n  \n            // 手动提交\n            c.commit();\n  \n        } catch (SQLException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n  \n    }\n}\n```\n### 2.spring\n-spring中的事务 作为 局部事务 ， 配置方式依赖于持久层使用的技术 \nspring整合jdbc \nspring整合hibernate\n\n-spring中即提供了编程式事务的管理方式，也提供了声明式事务的管理方式：\n【**编程式事务** TransactionTemplate\n\n模板类 将事务的管理过程封装模板类中】 \n\n【**声明式事务** AOP\n提供根接口 PlatFormTransactionManager 事务管理器接口 \n用于描述spring中事务如何管理[如何创建、如何提交、如何回滚] 】\n\n-声明式事务 \n底层采用AOP技术实现，将事务管理过程(创建、提交、回滚)封装在一个事务通知bean[AfterAdvice ThrowsAdvice]中; \n通过在ioc容器中配置切入点的方式，将这个事务通知bean提供的事务管理功能引用给需要事务的核心业务逻辑方法(DAO)\n相关连接[Spring中如何使用事务？](https://www.cnblogs.com/xym4869/p/8976949.html)","tags":["java"],"categories":["技术"]},{"title":"比较execute、executeUpdate的区别","url":"/tech-notes/the-different-execute-1565790905.html","content":"# 一、比较execute、executeUpdate的区别\n## 1.相同点：\n   不同1：\n\n        execute可以执行查询语句，然后通过getResultSet，把结果集取出来。\n\n        executeUpdate不能执行查询语句。\n\n    不同2:\n\n        execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等。\n\n        executeUpdate返回的是int，表示有多少条数据受到了影响。\n\n运行示例：\n```\nimport java.sql.*;\n \n/**\n * @author 15643\n * 比较execute和executeUpdate的区别\n */\npublic class ExcuteAndUpdate {\n\tpublic static void main(String[] args) {\n\t\tString driverName = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\";\n\t\tString dbUrl = \"jdbc:sqlserver://localhost:1433;DatabaseName=SC\";\n\t\tString userName = \"test\";\n\t\tString userPwd = \"test\";\n\t\tConnection conn = null;\n\t\tPreparedStatement pStmt = null;\n\t\ttry {\n\t\t\tClass.forName(driverName);\n\t\t\tconn = DriverManager.getConnection(dbUrl, userName, userPwd);\n\t\t\tString sql = \"update course set coursecredit = 5 where courseno like ?\";\n\t\t\tpStmt = conn.prepareStatement(sql);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\ttry {\n\t\t\tpStmt.setString(1, \"101_\");\n\t\t\t// executeUpdate返回的是int，表示有多少条数据受到了影响\n\t\t\tint cnt = pStmt.executeUpdate();\n\t\t\t// execute返回boolean类型，true表示执行的是查询语句，false表示执行的是insert,delete,update等等\n\t\t\tboolean isSelect = pStmt.execute();\n\t\t\tSystem.out.println(\"修改的条数：\" + cnt);\n\t\t\tSystem.out.println(\"是否查询语句:\" + isSelect);\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\ttry {\n\t\t\tif (pStmt != null)\n\t\t\t\tpStmt.close();\n\t\t\tif (conn != null)\n\t\t\t\tconn.close();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n\n运行截图：![jpg](https://img-blog.csdn.net/20180604203925360)\n# 二、事务\n## 1.事务简介\n-概念\n例如：在关系数据库中，一个事务可以是一条SQL语句，一组SQL语句或整个程序。\n-特性\n事务是恢复和并发控制的基本单位。\n事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。\n        原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。\n        一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n        隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n        持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。\n## 2.实例\n   假设业务操作是：对某同学的一科成绩减去5分，另一科成绩加上5分，预期结果是该同学的总分不变。\n但是在实际操作中把加分的语句不小心写错写成了 updata(而非update)----在没有使用事务的情况下，最后结果显而易见是总分增加了5分，而非期望的不变。那么，要如何操作才会避免这种事情发生呢？ \n   **使用事务：** \n   通过 c.setAutoCommit(false);关闭自动提交 使用 c.commit();进行手动提交 红色的代码就处于同一个事务当中，它们要么都成功，要么都失败 所以，虽然第一条SQL语句是可以执行的，但是第二条SQL语句有错误，其结果就是两条SQL语句都没有被提交。 除非两条SQL语句都是正确的\n\n```\n/**\n * @author 15643\n *\t事务的操作\n */\nimport java.sql.*;\n \npublic class Transation {\n\tpublic static void main(String[] args) {\n\t\tString driverName = \"com.microsoft.sqlserver.jdbc.SQLServerDriver\";\n\t\tString dbUrl = \"jdbc:sqlserver://localhost:1433;DatabaseName=SC\";\n\t\tString userName = \"test\";\n\t\tString userPwd = \"test\";\n\t\tConnection conn = null;\n\t\tStatement stmt = null;\n\t\tResultSet rs0 = null;\n\t\ttry {\n\t\t\tClass.forName(driverName);\n\t\t\tconn = DriverManager.getConnection(dbUrl, userName, userPwd);\n\t\t\tString sql0 = \"select finalscore from score where studentno = '10403201'\";\n\t\t\tstmt = conn.createStatement();\n\t\t\trs0 = stmt.executeQuery(sql0);//提取更新之前的数据\n\t\t\twhile(rs0.next()) {\n\t\t\t\tSystem.out.println(rs0.getDouble(1));\n\t\t\t}\n\t\t\tconn.setAutoCommit(false);// 关闭自动提交\n\t\t\tString sql1 = \"update score set finalscore = finalscore + 5 where studentno = '10403201'\";\n\t\t\tString sql2 = \"updata score set finalscore = finalscore - 5 where studentno = '10403201'\";\n\t\t\tstmt.execute(sql1);\n\t\t\tstmt.execute(sql2);\n\t\t\tconn.commit();//手动提交事务\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (ClassNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\ttry {\n\t\t\tif (stmt != null)\n\t\t\t\tstmt.close();\n\t\t\tif (conn != null)\n\t\t\t\tconn.close();\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n```\n来源[JDBC（四）之事务以及比较execute、executeUpdate的区别](https://blog.csdn.net/CNAHYZ/article/details/80572718)","tags":["java"],"categories":["技术"]},{"title":"Tomcat：8080端口被Oracle XE占用问题的解决","url":"/tech-notes/the-problem-Oracle-1565449247.html","content":"装上Oracle XE版本数据库后，再在Eclipse中运行Web项目时，提示启动Tomcat时遇到了错误，如下图所示：\n![jpg](https://img-blog.csdn.net/20170903145814710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXV0ZWJlbmJlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n经过搜索得知出现此错误是由于我装的Oracle XE版本数据库占用了Tomcat的8080端口，导致每次电脑启动后，我都需要先手动关闭掉被Oracle占用的8080端口，才能使Tomcat正常使用。为了解决这个问题，我把Oracle占用的端口从8080改为8081，具体操作如下：\n\n1.打开Oracle的SQL命令行 \n![jpg](https://img-blog.csdn.net/20170903151019979?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXV0ZWJlbmJlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n2.在SQL命令行中输入以下代码来修改端口\n```\nSQL> -- Change the HTTP/WEBDAV port from 8080 to 8081\nSQL> call dbms_xdb.cfg_update(updateXML(\n2      dbms_xdb.cfg_get()\n3      , '/xdbconfig/sysconfig/protocolconfig/httpconfig/http-port/text()'\n4      , 8081))\n5  /\n调用完成。\nSQL> -- Change the FTP port from 2100 to 2111\nSQL> call dbms_xdb.cfg_update(updateXML(\n2       dbms_xdb.cfg_get()\n3       , '/xdbconfig/sysconfig/protocolconfig/ftpconfig/ftp-port/text()'\n4       , 2111))\n5  /\n调用完成。\nSQL> COMMIT;\n提交完成。\nSQL> EXEC dbms_xdb.cfg_refresh;\nPL/SQL 过程已成功完成。\n```\n**有一点需要注意：在输入上述代码块之前，需要先连接上数据库，否则会提示“SP2-0640：未连接”**，SQL命令行连接代为```conn sys/密码 as sysdba;```回车，提示已连接，问题解决。如下图所示\n![jpg](https://img-blog.csdn.net/20170903152605531?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXV0ZWJlbmJlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n完整的操作过程如下图：\n![jpg](https://img-blog.csdn.net/20170903153423613?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbXV0ZWJlbmJlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n相关连接[Tomcat：8080端口被Oracle XE占用问题的解决](https://blog.csdn.net/mutebenben/article/details/77822328)","tags":["java"],"categories":["技术"]},{"title":"Java泛型中extends和super的区别","url":"/tech-notes/the-different-genericity-1565184981.html","content":"## <? extends T>和<? super T>\n\n<? extends T>和<? super T>是Java泛型中的“**通配符（Wildcards)**”和“**边界（Bounds）**”的概念。\n\n- <? extends T>：是指 “**上界通配符**（Upper Bounds Wildcards）”\n- <? super T>：是指 “**下界通配符**（Lower Bounds Wildcards）”\n\n### 为什么要用通配符和边界？\n使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。\n```\nclass Fruit {}\nclass Apple extends Fruit {}\n```\n然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：set( )和get( )方法\n```\nclass Plate<T>{\n    private T item;\n    public Plate(T t){item=t;}\n    public void set(T t){item=t;}\n    public T get(){return item;}\n}\n```\n现在我定义一个“水果盘子”，逻辑上水果盘子当然可以装苹果\n```\nPlate<Fruit> p=new Plate<Apple>(new Apple());\n```\n但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。\n```\nerror: incompatible types: Plate<Apple> cannot be converted to Plate<Fruit>\n```\n所以我的尴尬症就犯了。实际上，编译器脑袋里认定的逻辑是这样的：\n\n- **苹果 IS-A 水果**\n- **装苹果的盘子 NOT-IS-A 装水果的盘子**\n所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不可以把Plate的引用传递给Plate。\n\n为了让泛型用起来更舒服，Sun的大脑袋们就想出了<? extends T>和<? super T>的办法，来让”水果盘子“和”苹果盘子“之间发生关系。\n### 什么是上界？\n下面代码就是“上界通配符（Upper Bounds Wildcards）”：\n```\nPlate<？ extends Fruit>\n```\n翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。这和我们人类的逻辑就比较接近了。Plate<？ extends Fruit>和Plate<Apple>最大的区别就是：Plate<？ extends Fruit>是Plate<Fruit>以及Plate<Apple>的基类。直接的好处就是，我们可以用“苹果盘子”给“水果盘子”赋值了。\n```\nPlate<? extends Fruit> p=new Plate<Apple>(new Apple());\n```\n如果把Fruit和Apple的例子再扩展一下，食物分成水果和肉类，水果有苹果和香蕉，肉类有猪肉和牛肉，苹果还有两种青苹果和红苹果\n```\n//Lev 1\nclass Food{}\n\n//Lev 2\nclass Fruit extends Food{}\nclass Meat extends Food{}\n\n//Lev 3\nclass Apple extends Fruit{}\nclass Banana extends Fruit{}\nclass Pork extends Meat{}\nclass Beef extends Meat{}\n\n//Lev 4\nclass RedApple extends Apple{}\nclass GreenApple extends Apple{}\n```\n在这个体系中，下界通配符 Plate<？ extends Fruit> 覆盖下图中蓝色的区域\n![jpg](https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004120143-1731938777.png)\n### 什么是下界？\n相对应的，“下界通配符（Lower Bounds Wildcards）”：\n```\nPlate<？ super Fruit>\n```\n表达的就是相反的概念：一个能放水果以及一切是水果基类的盘子。Plate<？ super Fruit>是Plate<Fruit>的基类，但不是Plate<Apple>的基类。对应刚才那个例子，Plate<？ super Fruit>覆盖下图中红色的区域。\n![jpg](https://images2015.cnblogs.com/blog/820480/201611/820480-20161125004216471-1377946016.png)\n### 上下界通配符的副作用\n边界让Java不同泛型之间的转换更容易了。但不要忘记，这样的转换也有一定的副作用。那就是容器的部分功能可能失效。\n\n还是以刚才的Plate为例。我们可以对盘子做两件事，往盘子里set()新东西，以及从盘子里get()东西。\n```\nclass Plate<T>{\n    private T item;\n    public Plate(T t){item=t;}\n    public void set(T t){item=t;}\n    public T get(){return item;}\n}\n```\n上界<? extends T>不能往里存，只能往外取\n**<? extends Fruit>会使往盘子里放东西的set( )方法失效。但取东西get( )方法还有效。比如下面例子里两个set()方法，插入Apple和Fruit都报错**\n```\nPlate<? extends Fruit> p=new Plate<Apple>(new Apple());\n    \n//不能存入任何元素\np.set(new Fruit());    //Error\np.set(new Apple());    //Error\n\n//读取出来的东西只能存放在Fruit或它的基类里。\nFruit newFruit1=p.get();\nObject newFruit2=p.get();\nApple newFruit3=p.get();    //Error\n```\n原因是编译器只知道容器内是Fruit或者它的派生类，但具体是什么类型不知道。可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在看到后面用Plate赋值以后，盘子里没有被标上有“苹果”。而是标上一个占位符：CAP#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，代号CAP#1。然后无论是想往里插入Apple或者Meat或者Fruit编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。\n\n所以通配符<?>和类型参数的区别就在于，对编译器来说所有的T都代表同一种类型。比如下面这个泛型方法里，三个T都指代同一个类型，要么都是String，要么都是Integer。\n```\npublic <T> List<T> fill(T... t);\n```\n但通配符<?>没有这种约束，Plate<?>单纯的就表示：盘子里放了一个东西，是什么我不知道。\n\n所以题主问题里的错误就在这里，Plate<？ extends Fruit>里什么都放不进去。\n**下界<? super T>不影响往里存，但往外取只能放在Object对象里\n使用下界<? super Fruit>会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里。set( )方法正常。**\n```\nPlate<? super Fruit> p=new Plate<Fruit>(new Fruit());\n\n//存入元素正常\np.set(new Fruit());\np.set(new Apple());\n\n//读取出来的东西只能存放在Object类里。\nApple newFruit3=p.get();    //Error\nFruit newFruit1=p.get();    //Error\nObject newFruit2=p.get();\n```\n因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然元素是Fruit的基类，那往里存粒度比Fruit小的都可以。但往外读取元素就费劲了，只有所有类的基类Object对象才能装下。但这样的话，元素的类型信息就全部丢失。\n### PECS原则\n最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了：\n- 频繁往外读取内容的，适合用上界Extends。\n- 经常往里插入的，适合用下界Super。\n\n来源[Java 泛型 <? super T> 中 super 怎么 理解？与 extends 有何不同？](https://www.zhihu.com/question/20400700)","tags":["java"],"categories":["技术"]},{"title":"HashCode原理，为什么HashMap那么快？","url":"/tech-notes/the-Principle-HashCode-1564839206.html","content":"HashCode作为一个算法，简单来说它就是把一串字符串变成一串数字仅此而已\n以下是JavaAPI提供的String的HashCode生成方法\n```\ns[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n```\n我们不需要去理解这个算法，或者叫你去写\n那么问题来了，它跟HashMap有什么关系？\n众所周知，HashMap的特性是键值对，那么键值对背后究竟是怎么存储的呢？\n我们可以通过一个case来理解其中的联系\n设计一个HashMap类(LinkedList)\n>设计一个put(String key,Object value)方法\n\n通过HashCode算法得到key对应的hashcode码，把它作为下标，定位到数组相对应位置\n如果该位置没有数据，则把字符串和对象组合成键值对Entry，再创建一个LinkedList，把键值对，放进LinkedList中，最后把LinkedList 保存在这个位置。\n如果该位置有数据，一定是一个LinkedList,则把字符串和对象组合成键值对Entry，插入到LinkedList后面。\n>设计 Object get(String key) 方法\n\n通过HashCode算法得到key对应的hashcode码，把它作为下标，定位到数组相对应位置\n如果这个位置没有数据，则返回空\n如果这个位置有数据，则挨个比较其中键值对的键-字符串，是否equals，找到匹配的，把键值对的值，返回出去。找不到匹配的，就返回空\n![jpg](https://upload-images.jianshu.io/upload_images/14876243-ff5d3596d2a93cfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/567/format/webp)\n## 空间换取时间的方法加快效率","tags":["java"],"categories":["技术"]},{"title":"ArrayList与LinkedList的区别","url":"/tech-notes/the-different-collection-1564584613.html","content":"## ArrayList和LinkedList的区别\nArrayList **插入，删除数据慢**\nLinkedList， **插入，删除数据快**\nArrayList是顺序结构，所以**定位很快**，指哪找哪。 就像电影院位置一样，有了电影票，一下就找到位置了。\nLinkedList 是链表结构，就像手里的一串佛珠，要找出第99个佛珠，必须得一个一个的数过去，所以**定位慢**\n\n## 插入数据\n\n```\npackage collection;\n \nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n \npublic class TestCollection {\n    public static void main(String[] args) {\n        List<Integer> l;\n        l = new ArrayList<>();\n        insertFirst(l, \"ArrayList\");\n \n        l = new LinkedList<>();\n        insertFirst(l, \"LinkedList\");\n \n    }\n \n    private static void insertFirst(List<Integer> l, String type) {\n        int total = 1000 * 100;\n        final int number = 5;\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < total; i++) {\n            l.add(0, number);\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"在%s 最前面插入%d条数据，总共耗时 %d 毫秒 %n\", type, total, end - start);\n    }\n \n}\n```\n## 定位数据\n\n```\npackage collection;\n \nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n \npublic class TestCollection {\n    public static void main(String[] args) {\n        List<Integer> l;\n        l = new ArrayList<>();\n        modify(l, \"ArrayList\");\n \n        l = new LinkedList<>();\n        modify(l, \"LinkedList\");\n \n    }\n \n    private static void modify(List<Integer> l, String type) {\n        int total = 100 * 1000;\n        int index = total/2;\n        final int number = 5;\n        //初始化\n        for (int i = 0; i < total; i++) {\n            l.add(number);\n        }\n         \n        long start = System.currentTimeMillis();\n \n        for (int i = 0; i < total; i++) {\n             int n = l.get(index);\n             n++;\n             l.set(index, n);\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"%s总长度是%d，定位到第%d个数据，取出来，加1，再放回去%n 重复%d遍，总共耗时 %d 毫秒 %n\", type,total, index,total, end - start);\n        System.out.println();\n    }\n \n}\n```\n相关连接[ARRAYLIST和LINKEDLIST的区别详解](http://how2j.cn/k/collection/collection-arraylist-vs-linkedlist/690.html#nowhere)","tags":["java"],"categories":["技术"]},{"title":"ArrList与HashSet的区别","url":"/tech-notes/the-different-collection-1564583728.html","content":"## 是否有顺序\nArrayList: 有顺序\nHashSet: 无顺序\n\nHashSet的具体顺序，既不是按照插入顺序，也不是按照hashcode的顺序。\n以下是**HasetSe源代码**中的部分注释\n```\n/**\n * It makes no guarantees as to the iteration order of the set; \n * in particular, it does not guarantee that the order will remain constant over time. \n*/\n```\n>不保证Set的迭代顺序; 确切的说，在不同条件下，元素的顺序都有可能不一样\n换句话说，同样是插入0-9到HashSet中， 在JVM的不同版本中，看到的顺序都是不一样的。 所以在开发的时候，不能依赖于某种**臆测的顺序**，这个顺序本身是**不稳定的**\n```\npackage collection;\n   \nimport java.util.ArrayList;\nimport java.util.HashSet;\n    \npublic class TestCollection {\n    public static void main(String[] args) {\n           \n        ArrayList<Integer> numberList =new ArrayList<Integer>();\n        //List中的数据按照插入顺序存放\n        System.out.println(\"----------List----------\");\n        System.out.println(\"向List 中插入 9 5 1\");\n        numberList.add(9);\n        numberList.add(5);\n        numberList.add(1);\n        System.out.println(\"List 按照顺序存放数据:\");\n        System.out.println(numberList);\n        System.out.println(\"----------Set----------\");\n        HashSet<Integer> numberSet =new HashSet<Integer>();\n        System.out.println(\"向Set 中插入9 5 1\");\n        //Set中的数据不是按照插入顺序存放\n        numberSet.add(9);\n        numberSet.add(5);\n        numberSet.add(1);\n        System.out.println(\"Set 不是按照顺序存放数据:\");\n        System.out.println(numberSet);\n           \n    }\n}\n```\n## List中的数据可以重复\nSet中的数据不能够重复\n重复判断标准是:\n首先看hashcode是否相同\n如果hashcode不同，则认为是不同数据\n如果hashcode相同，再比较equals，如果equals相同，则是相同数据，否则是不同数据\n```\npackage collection;\n   \nimport java.util.ArrayList;\nimport java.util.HashSet;\n    \npublic class TestCollection {\n    public static void main(String[] args) {\n           \n        ArrayList<Integer> numberList =new ArrayList<Integer>();\n        //List中的数据可以重复\n        System.out.println(\"----------List----------\");\n        System.out.println(\"向List 中插入 9 9\");\n        numberList.add(9);\n        numberList.add(9);\n        System.out.println(\"List 中出现两个9:\");\n        System.out.println(numberList);\n        System.out.println(\"----------Set----------\");\n        HashSet<Integer> numberSet =new HashSet<Integer>();\n        System.out.println(\"向Set 中插入9 9\");\n        //Set中的数据不能重复\n        numberSet.add(9);\n        numberSet.add(9);\n        System.out.println(\"Set 中只会保留一个9:\");\n        System.out.println(numberSet);\n           \n    }\n}\n```\n相关连接[JAVA ARRAYLIST和HASHSET的区别](http://how2j.cn/k/collection/collection-arraylist-vs-hashset/367.html)","tags":["java"],"categories":["技术"]},{"title":"二叉树排序-遍历","url":"/tech-notes/the-practise-ArrayList-1564242141.html","content":"\n利用二叉树把**排好序的数据**，遍历成我们常用的List或者数组的形式\n\n二叉树的遍历分左序，中序，右序\n左序即： 中间的数遍历后放在左边\n中序即： 中间的数遍历后放在中间\n右序即： 中间的数遍历后放在右边\n如图所见，我们希望遍历后的结果是从小到大的，所以应该采用中序遍历\n![jpg](https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2595362298,2802985994&fm=26&gp=0.jpg)\n\n```\npackage collection;\n \nimport java.util.ArrayList;\nimport java.util.List;\n \npublic class Node {\n    // 左子节点\n    public Node leftNode;\n    // 右子节点\n    public Node rightNode;\n  \n    // 值\n    public Object value;\n  \n    // 插入 数据\n    public void add(Object v) {\n        // 如果当前节点没有值，就把数据放在当前节点上\n        if (null == value)\n            value = v;\n  \n        // 如果当前节点有值，就进行判断，新增的值与当前值的大小关系\n        else {\n            // 新增的值，比当前值小或者相同\n             \n            if ((Integer) v -((Integer)value) <= 0) {\n                if (null == leftNode)\n                    leftNode = new Node();\n                leftNode.add(v);\n            }\n            // 新增的值，比当前值大\n            else {\n                if (null == rightNode)\n                    rightNode = new Node();\n                rightNode.add(v);\n            }\n  \n        }\n  \n    }\n```\n以上是二叉树排序，接下来是转换\n```\n // 中序遍历所有的节点\n    public List<Object> values() {\n        List<Object> values = new ArrayList<>();\n  \n        // 左节点的遍历结果\n        if (null != leftNode)\n            values.addAll(leftNode.values());\n  \n        // 当前节点\n        values.add(value);\n  \n        // 右节点的遍历结果\n        if (null != rightNode)\n  \n            values.addAll(rightNode.values());\n  \n        return values;\n    }\n  \n    public static void main(String[] args) {\n  \n        int randoms[] = new int[] { 67, 7, 30, 73, 10, 0, 78, 81, 10, 74 };\n  \n        Node roots = new Node();\n        for (int number : randoms) {\n            roots.add(number);\n        }\n  \n        System.out.println(roots.values());\n  \n    }\n}\n```\n拓展：[几道和「二叉树」有关的算法面试题](https://www.itcodemonkey.com/article/13686.html)","tags":["java"],"categories":["技术"]},{"title":"删除ArrayList中的数据","url":"/tech-notes/the-practise-ArrayList-1564232895.html","content":"\n首先初始化一个Hero集合，里面放100个Hero对象，名称分别是从\nhero 0\nhero 1\nhero 2\n...\nhero 99.\n\n通过遍历的手段，删除掉名字编号是8的倍数的对象\n\n\n>这个练习的考点是，不能够在使用Iterator和增强for循环遍历数据的同时，删除数据，否则会抛出**ConcurrentModificationException**\n\n>解决办法，是准备一个临时容器，专门用来保存需要删除的对象。 然后再删掉\n\n```\npackage collection;\nimport java.util.ArrayList;\nimport java.util.List;\n \nimport charactor.Hero;\n \npublic class TestCollection {\n \n    public static void main(String[] args) {\n        List<Hero> heros = new ArrayList<Hero>();\n \n        // 放100个Hero进入容器\n        for (int i = 0; i < 100; i++) {\n            heros.add(new Hero(\"hero name \" + i));\n        }\n \n        //准备一个容器，专门用来装要删除的对象\n        List<Hero> deletingHeros = new ArrayList<>();\n \n        for (Hero h : heros) {\n            int id = Integer.parseInt(h.name.substring(10));\n            if (0 == id % 8)\n                deletingHeros.add(h);\n        }\n        for (Hero h : deletingHeros) {\n            heros.remove(h);\n        }\n    //heros.removeAll(deletingHeros); //直接通过removeAll删除多个Hero对象\n        System.out.println(heros);\n    }\n \n}\n```","tags":["java"],"categories":["技术"]},{"title":"其他测试","url":"/others/the-test-others-1563626682.html","content":"\n其他分支测试","tags":["hexo"],"categories":["其他"]},{"title":"开始记录-学习日记","url":"/humanities/first-daliy-note-1563625610.html","content":"\n# 第一次记录\n\n\n\n## 关于学习记录\n\n以后随机抽时间发布，但每星期至少两篇对于学习的感悟，以及值得记录的知识点。","tags":["碎碎念"],"categories":["人文"]},{"title":"hexo常用语句","url":"/tech-notes/the-hexo-normal-1563374311.html","content":"\nHexo 约有二十个命令，但普通用户经常使用的大概只有下列几个:\n\n# hexo s\n`hexo s`\n\n启动本地服务器，用于预览主题。默认地址： http://localhost:4000/\n\n- hexo s 是 hexo server 的缩写，命令效果一致；\n- 预览的同时可以修改文章内容或主题代码，保存后刷新页面即可；\n- 对 Hexo 根目录 -config.yml 的修改，需要重启；\n\n\n# hexo g\n`hexo g`\n\n清除缓存文件db.json 和已生成的静态文件public\n\n# hexo d\n`hexo d`\n\n是hexo deploy的简写形式，部署静态文件到设定的仓库\n\n# hexo clean && hexo g && hexo d\n`hexo clean && hexo g && hexo d`\n\n常用的组合命令，清除缓存，生成静态文件，并部署到指定仓库\n","tags":["hexo"],"categories":["技术"]},{"title":"测试2","url":"/tech-notes/the-test-normal-1563374174.html","content":"\n123123","tags":["练习"],"categories":["技术"]},{"title":"测试","url":"/tech-notes/the-test-null.html","tags":["练习"],"categories":["技术"]},{"title":"hexo练习","url":"/tech-notes/first-practise-null.html","content":"# 第一次练习\n\n熟悉相关语句","tags":["练习"],"categories":["技术"]},{"title":"hexo发布文章","url":"/tech-notes/first-hexo-undefined.html","content":"# 一级标题\n## 二级标题\n### 三级标题\n\n> 这个是引用\n\n--------------------\n\n*斜体*\n\n**加粗**\n\n![jpg](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1561983930916&di=c5c74316b89e531f12f7acfacc518d43&imgtype=0&src=http%3A%2F%2Fg.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2F203fb80e7bec54e7f0e0839fb7389b504fc26a27.jpg)\n\n[百度](https://www.baidu.com)\n\n```c\nvar i = 0;\n```\n- 列表\n- 列表\n- 列表\n\n1.列表\n2.列表\n3.列表\n\n|表头|表头|表头|\n|:-:|:-|-:|\n|内容|内容|内容|\n|内容|内容|内容|\n\n~~删除线~~\n\n`#` 我打算在文字中加那些","tags":["hexo"],"categories":["技术"]},{"title":"为何建站&为何写作","url":"/about/index.html","content":"\n# 为何建站"},{"title":"优秀的资源","url":"/links/index.html","content":"\n# 学习网站"},{"title":"QA - 帮助中心","url":"/help/index.html","content":"\n# Q: 这网站怎么弄的，还挺好看的啊？"}]